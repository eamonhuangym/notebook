# 深度优先搜索

~~~c
void dfs(int step)
{
    判断边界;
    尝试每种可能 for(int i=1;i<=n;i++)
    {
        继续下一步 dfs(step+1);
    }
    返回;
}
~~~

输入n，输入1~n的全排列

~~~c
#include <stdio.h>
int n,a[100],book[100];

void dfs(int step){
	if(step==n+1){
		for(int i=1;i<=n;i++){
			printf("%d ",a[i]);
		} 
		printf("\n");
		return;
	}
	for(int i=1;i<=n;i++){
		if(book[i]==0){
			a[step]=i;
			book[i]=1;
			dfs(step+1);
			book[i]=0;
		}
	}
} 
int main()
{
	scanf("%d",&n);
	dfs(1);
	return 0;
}
~~~

现有1~9九个数字，自由排列使_ _ _ + _ _ _ = _ _ _ 成立，求所有情况

~~~c
#include <stdio.h>
int a[10],book[10];
void dfs(int step){
	if(step==10){
		if(a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==a[7]*100+a[8]*10+a[9])
			printf("%d%d%d+%d%d%d=%d%d%d\n",a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]);
		return;
	}
	for(int i=1;i<=9;i++){
		if(book[i]==0){
			a[step]=i;
			book[i]=1;
			dfs(step+1);
			book[i]=0;
		} 
	}
}
int main()
{
	dfs(1);
	return 0;
} 
~~~

